-- Temporal Coverage Monitoring Queries
-- Generated by Temporal Anomaly Investigation

-- Daily Gap Detection
-- Daily Gap Detection Query
            WITH date_series AS (
                SELECT date(julianday('now') - days.value) as check_date
                FROM (
                    SELECT 0 as value UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 
                    UNION SELECT 4 UNION SELECT 5 UNION SELECT 6
                ) days
            ),
            daily_counts AS (
                SELECT race_date, COUNT(*) as race_count
                FROM races
                WHERE race_date >= date('now', '-7 days')
                GROUP BY race_date
            )
            SELECT ds.check_date, 
                   COALESCE(dc.race_count, 0) as races,
                   CASE WHEN dc.race_count IS NULL THEN 'GAP DETECTED' ELSE 'OK' END as status
            FROM date_series ds
            LEFT JOIN daily_counts dc ON ds.check_date = dc.race_date
            ORDER BY ds.check_date DESC;

==================================================

-- Retroactive Data Detection
-- Retroactive Data Detection Query
            WITH race_sequence AS (
                SELECT race_id, race_date, created_at,
                       LAG(race_date) OVER (ORDER BY created_at) as prev_race_date,
                       LAG(created_at) OVER (ORDER BY created_at) as prev_created_at
                FROM races
                WHERE created_at >= datetime('now', '-7 days')
                ORDER BY created_at
            )
            SELECT race_id, race_date, created_at, prev_race_date,
                   'RETROACTIVE DATA' as alert_type
            FROM race_sequence
            WHERE race_date < prev_race_date AND created_at > prev_created_at;

==================================================

-- Venue Anomaly Detection
-- Venue Anomaly Detection Query
            SELECT venue, COUNT(*) as race_count,
                   MIN(race_date) as first_race, 
                   MAX(race_date) as last_race,
                   CASE 
                       WHEN LENGTH(venue) < 3 THEN 'SHORT_NAME'
                       WHEN venue = UPPER(venue) AND LENGTH(venue) <= 4 THEN 'ABBREVIATION'
                       WHEN venue NOT GLOB '*[A-Za-z]*' THEN 'NON_ALPHABETIC'
                       ELSE 'NORMAL'
                   END as venue_type
            FROM races
            WHERE created_at >= datetime('now', '-30 days')
            GROUP BY venue
            HAVING venue_type != 'NORMAL'
            ORDER BY race_count DESC;

==================================================

-- Collection Pattern Monitoring
-- Collection Pattern Monitoring Query
            SELECT 
                DATE(created_at) as collection_date,
                COUNT(*) as races_collected,
                COUNT(DISTINCT venue) as unique_venues,
                MIN(race_date) as earliest_race_date,
                MAX(race_date) as latest_race_date,
                (julianday(MAX(race_date)) - julianday(MIN(race_date))) as date_span_days,
                CASE 
                    WHEN COUNT(*) > 50 THEN 'HIGH_VOLUME'
                    WHEN COUNT(*) < 5 THEN 'LOW_VOLUME'
                    WHEN date_span_days > 7 THEN 'WIDE_DATE_RANGE'
                    ELSE 'NORMAL'
                END as pattern_type
            FROM races
            WHERE created_at >= datetime('now', '-30 days')
            GROUP BY DATE(created_at)
            HAVING pattern_type != 'NORMAL'
            ORDER BY collection_date DESC;

==================================================

