#!/usr/bin/env python3
"""
Corrected TGR Scraper
====================

This script creates a TGR scraper based on the official TGR documentation
that correctly interprets the column meanings and data structure.

Based on official TGR documentation:
- F = Finishing Position (1st, 2nd, 3rd, etc.)
- B = Starting Box (1-8)
- AT = Actual Time (individual dog's time)
- WT = Winning Time (winner's time for that race)
- T = Track/Venue
- D = Distance
- G = Grade
- M = Margin
- SP = Starting Price
"""

import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
import re

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def create_corrected_tgr_scraper():
    """Create a corrected TGR scraper based on official documentation."""
    
    from src.collectors.the_greyhound_recorder_scraper import TheGreyhoundRecorderScraper
    
    class CorrectedTGRScraper(TheGreyhoundRecorderScraper):
        """TGR Scraper with correct column interpretation based on official docs."""
        
        def fetch_enhanced_dog_data(self, dog_name: str, limit_days: int = 365) -> Dict[str, Any]:
            """Enhanced dog data collection using correct TGR parsing."""
            
            logger.info(f"üêï Fetching TGR data for: {dog_name} (using official column definitions)")
            
            enhanced_data = {
                'dog_name': dog_name,
                'form_entries': [],
                'performance_summary': {},
                'venue_analysis': {},
                'distance_analysis': {},
                'recent_comments': [],
                'expert_insights': []
            }
            
            try:
                # Get form guides
                form_guides = self.fetch_form_guides()
                
                # Process each meeting to find races with this dog
                processed_meetings = 0
                for meeting in form_guides.get('meetings', [])[:15]:  # Check more meetings
                    if meeting.get('long_form_url') and processed_meetings < 10:
                        try:
                            logger.debug(f"Processing meeting: {meeting.get('meeting_title', meeting['long_form_url'])}")
                            
                            # Extract dog histories from this meeting's form guide
                            dog_histories = self._extract_dog_histories_from_meeting(
                                meeting['long_form_url'], dog_name
                            )
                            
                            if dog_histories:
                                enhanced_data['form_entries'].extend(dog_histories)
                                logger.info(f"Found {len(dog_histories)} race entries for {dog_name} in meeting")
                            
                            processed_meetings += 1
                            
                        except Exception as e:\n                            logger.debug(f\"Error processing meeting {meeting.get('meeting_title')}: {e}\")\n                            continue\n                \n                # Calculate performance metrics if we found entries\n                if enhanced_data['form_entries']:\n                    logger.info(f\"Calculating performance metrics for {len(enhanced_data['form_entries'])} race entries\")\n                    \n                    enhanced_data['performance_summary'] = self._calculate_performance_metrics(\n                        enhanced_data['form_entries']\n                    )\n                    \n                    enhanced_data['venue_analysis'] = self._analyze_venue_performance(\n                        enhanced_data['form_entries']\n                    )\n                    \n                    enhanced_data['distance_analysis'] = self._analyze_distance_performance(\n                        enhanced_data['form_entries']\n                    )\n                    \n                    enhanced_data['recent_comments'] = self._extract_recent_comments(\n                        enhanced_data['form_entries']\n                    )\n                \n                logger.info(f\"‚úÖ Enhanced data collected for {dog_name}: {len(enhanced_data['form_entries'])} total race entries\")\n                \n            except Exception as e:\n                logger.error(f\"‚ùå Failed to fetch enhanced dog data for {dog_name}: {e}\")\n            \n            return enhanced_data\n        \n        def _extract_dog_histories_from_meeting(self, meeting_url: str, target_dog_name: str) -> List[Dict[str, Any]]:\n            \"\"\"Extract detailed racing history for a dog from TGR form guide page.\"\"\"\n            \n            if not meeting_url.startswith('http'):\n                meeting_url = f\"https://www.thegreyhoundrecorder.com.au{meeting_url}\"\n            \n            soup = self._get(meeting_url)\n            if not soup:\n                return []\n            \n            dog_histories = []\n            target_name_clean = target_dog_name.upper().strip()\n            \n            try:\n                # Look for the main racing data table containing dog histories\n                main_table = self._find_main_racing_table(soup)\n                \n                if main_table:\n                    logger.debug(f\"Found main racing table\")\n                    dog_histories = self._extract_dog_histories_from_table(main_table, target_name_clean)\n                \n                # Fallback: look for alternative structures\n                if not dog_histories:\n                    dog_histories = self._extract_dog_histories_alternative(soup, target_name_clean)\n                \n            except Exception as e:\n                logger.debug(f\"Error extracting dog histories from {meeting_url}: {e}\")\n            \n            return dog_histories\n        \n        def _find_main_racing_table(self, soup) -> Optional:\n            \"\"\"Find the main table containing racing form data.\"\"\"\n            \n            # Look for tables that contain TGR form data structure\n            tables = soup.find_all('table')\n            \n            for table in tables:\n                rows = table.find_all('tr')\n                if len(rows) < 3:  # Need header + at least 2 data rows\n                    continue\n                \n                # Check if this looks like the main form table\n                header_row = rows[0] if rows else None\n                if header_row:\n                    header_cells = header_row.find_all(['th', 'td'])\n                    header_text = ' '.join([cell.get_text(strip=True).lower() for cell in header_cells])\n                    \n                    # Look for TGR-specific headers: F, B, W, D, T, G, AT, WT, etc.\n                    tgr_indicators = ['finishing', 'position', 'box', 'weight', 'distance', 'time', 'grade', 'actual', 'winning']\n                    \n                    if any(indicator in header_text for indicator in tgr_indicators):\n                        logger.debug(f\"Found main racing table with headers: {[cell.get_text(strip=True) for cell in header_cells]}\")\n                        return table\n                \n                # Also check if data rows contain racing data patterns\n                sample_rows = rows[1:4]  # Check first few data rows\n                racing_pattern_count = 0\n                \n                for row in sample_rows:\n                    row_text = row.get_text().lower()\n                    # Look for racing indicators\n                    if any(indicator in row_text for indicator in ['ballarat', 'bendigo', 'sandown', 'can', 'man', '1st', '2nd', '3rd']):\n                        racing_pattern_count += 1\n                \n                if racing_pattern_count >= 2:  # At least 2 rows with racing data\n                    logger.debug(f\"Found racing table with {racing_pattern_count} racing data rows\")\n                    return table\n            \n            return None\n        \n        def _extract_dog_histories_from_table(self, table, target_dog_name: str) -> List[Dict[str, Any]]:\n            \"\"\"Extract racing histories for a specific dog from the main racing table.\"\"\"\n            \n            dog_histories = []\n            rows = table.find_all('tr')\n            \n            if not rows:\n                return dog_histories\n            \n            # Try to identify column headers\n            header_row = rows[0]\n            headers = [cell.get_text(strip=True).upper() for cell in header_row.find_all(['th', 'td'])]\n            \n            logger.debug(f\"Table headers: {headers}\")\n            \n            # Map TGR column abbreviations to our field names\n            column_mapping = {\n                'F': 'finish_position',\n                'B': 'starting_box', \n                'W': 'weight',\n                'D': 'distance',\n                'T': 'track',\n                'G': 'grade',\n                'AT': 'actual_time',\n                'WT': 'winning_time',\n                'BON': 'best_time_of_night',\n                'M': 'margin',\n                'SP': 'starting_price',\n                'A1S': 'sectional_1',\n                'A2S': 'sectional_2',\n                'A3S': 'sectional_3'\n            }\n            \n            # Process each data row\n            for row in rows[1:]:\n                cells = row.find_all(['td', 'th'])\n                \n                # Check if this row contains our target dog\n                row_text = row.get_text().upper()\n                if target_dog_name not in row_text:\n                    continue\n                \n                logger.debug(f\"Found row with {target_dog_name}: {[cell.get_text(strip=True) for cell in cells]}\")\n                \n                # Extract data based on column positions\n                race_entry = {\n                    'dog_name': target_dog_name,\n                    'race_date': None,\n                    'venue': None,\n                    'distance': None,\n                    'starting_box': None,\n                    'finish_position': None,\n                    'actual_time': None,\n                    'winning_time': None,\n                    'grade': None,\n                    'weight': None,\n                    'margin': None,\n                    'starting_price': None,\n                    'sectional_1': None,\n                    'sectional_2': None,\n                    'sectional_3': None,\n                    'best_time_of_night': None\n                }\n                \n                # Extract data based on header mapping\n                for i, cell in enumerate(cells):\n                    if i >= len(headers):\n                        break\n                        \n                    header = headers[i]\n                    cell_text = cell.get_text(strip=True)\n                    \n                    if header in column_mapping:\n                        field_name = column_mapping[header]\n                        \n                        # Type conversion based on field\n                        if field_name == 'starting_box' and cell_text.isdigit():\n                            race_entry[field_name] = int(cell_text)\n                        elif field_name == 'finish_position':\n                            race_entry[field_name] = self._normalize_position(cell_text)\n                        elif field_name in ['actual_time', 'winning_time'] and self._is_race_time(cell_text):\n                            race_entry[field_name] = float(cell_text)\n                        elif field_name == 'distance' and self._is_distance(cell_text):\n                            race_entry[field_name] = cell_text\n                        elif field_name == 'track' and cell_text:\n                            race_entry['venue'] = self._normalize_venue(cell_text)\n                        else:\n                            race_entry[field_name] = cell_text\n                    \n                    # Also try pattern-based extraction for key fields\n                    elif self._is_date(cell_text):\n                        race_entry['race_date'] = cell_text\n                    elif self._is_venue_abbreviation(cell_text):\n                        race_entry['venue'] = self._expand_venue_abbreviation(cell_text)\n                \n                # Only add if we found meaningful racing data\n                if (race_entry['finish_position'] or race_entry['actual_time'] or \n                    race_entry['venue'] or race_entry['race_date']):\n                    dog_histories.append(race_entry)\n                    logger.debug(f\"Added race entry: {race_entry}\")\n            \n            return dog_histories\n        \n        def _extract_dog_histories_alternative(self, soup, target_dog_name: str) -> List[Dict[str, Any]]:\n            \"\"\"Alternative extraction method for racing histories.\"\"\"\n            \n            dog_histories = []\n            \n            # Look for dog name mentions and extract surrounding racing data\n            dog_mentions = soup.find_all(string=lambda text: text and target_dog_name.lower() in text.lower())\n            \n            for mention in dog_mentions:\n                parent = mention.parent if hasattr(mention, 'parent') else None\n                if not parent:\n                    continue\n                \n                # Look for racing data in the same row or nearby elements\n                racing_data = self._extract_racing_data_from_context(parent, target_dog_name)\n                if racing_data:\n                    dog_histories.extend(racing_data)\n            \n            return dog_histories\n        \n        def _extract_racing_data_from_context(self, element, dog_name: str) -> List[Dict[str, Any]]:\n            \"\"\"Extract racing data from the context around a dog name mention.\"\"\"\n            \n            racing_entries = []\n            \n            # Check if we're in a table row\n            row = element.find_parent('tr')\n            if row:\n                cells = row.find_all(['td', 'th'])\n                if len(cells) >= 5:  # Need sufficient data\n                    race_entry = self._parse_racing_row_cells(cells, dog_name)\n                    if race_entry:\n                        racing_entries.append(race_entry)\n            \n            # Check siblings for additional racing data\n            if hasattr(element, 'find_next_siblings'):\n                for sibling in element.find_next_siblings()[:5]:  # Check next 5 siblings\n                    sibling_text = sibling.get_text(strip=True)\n                    if len(sibling_text) > 10 and self._contains_racing_indicators(sibling_text):\n                        race_entry = self._parse_racing_text(sibling_text, dog_name)\n                        if race_entry:\n                            racing_entries.append(race_entry)\n            \n            return racing_entries\n        \n        def _parse_racing_row_cells(self, cells: List, dog_name: str) -> Optional[Dict[str, Any]]:\n            \"\"\"Parse racing data from table row cells.\"\"\"\n            \n            race_entry = {\n                'dog_name': dog_name,\n                'race_date': None,\n                'venue': None,\n                'distance': None,\n                'starting_box': None,\n                'finish_position': None,\n                'actual_time': None,\n                'winning_time': None,\n                'grade': None\n            }\n            \n            times_found = []\n            \n            for cell in cells:\n                cell_text = cell.get_text(strip=True)\n                \n                if self._is_date(cell_text):\n                    race_entry['race_date'] = cell_text\n                elif self._is_venue_abbreviation(cell_text):\n                    race_entry['venue'] = self._expand_venue_abbreviation(cell_text)\n                elif self._is_distance(cell_text):\n                    race_entry['distance'] = cell_text\n                elif self._is_box_number(cell_text):\n                    race_entry['starting_box'] = int(cell_text)\n                elif self._is_finish_position(cell_text):\n                    race_entry['finish_position'] = self._normalize_position(cell_text)\n                elif self._is_race_time(cell_text):\n                    times_found.append(float(cell_text))\n                elif self._is_grade(cell_text):\n                    race_entry['grade'] = cell_text\n            \n            # Assign times: first = actual time, second = winning time\n            if len(times_found) >= 1:\n                race_entry['actual_time'] = times_found[0]\n            if len(times_found) >= 2:\n                race_entry['winning_time'] = times_found[1]\n            \n            # Only return if we have meaningful data\n            return race_entry if (race_entry['finish_position'] or race_entry['actual_time']) else None\n        \n        def _normalize_position(self, position_text: str) -> int:\n            \"\"\"Normalize finishing position to integer.\"\"\"\n            \n            if position_text.isdigit():\n                return int(position_text)\n            \n            # Extract number from ordinal (1st, 2nd, etc.)\n            match = re.search(r'(\\d+)', position_text)\n            if match:\n                return int(match.group(1))\n            \n            return None\n        \n        def _normalize_venue(self, venue_text: str) -> str:\n            \"\"\"Normalize venue name.\"\"\"\n            return self._expand_venue_abbreviation(venue_text)\n        \n        def _is_venue_abbreviation(self, text: str) -> bool:\n            \"\"\"Check if text is a venue abbreviation.\"\"\"\n            venue_abbrevs = ['CAN', 'MAN', 'BAL', 'BEN', 'SAN', 'MEL', 'ASC', 'RIC', 'HOR']\n            return text.upper() in venue_abbrevs\n        \n        def _expand_venue_abbreviation(self, abbrev: str) -> str:\n            \"\"\"Expand venue abbreviation to full name.\"\"\"\n            venue_map = {\n                'CAN': 'Cannington',\n                'MAN': 'Mandurah', \n                'BAL': 'Ballarat',\n                'BEN': 'Bendigo',\n                'SAN': 'Sandown',\n                'MEL': 'Melbourne',\n                'ASC': 'Ascot Park',\n                'RIC': 'Richmond',\n                'HOR': 'Horsham'\n            }\n            return venue_map.get(abbrev.upper(), abbrev)\n        \n        def _is_date(self, text: str) -> bool:\n            \"\"\"Check if text looks like a date.\"\"\"\n            date_patterns = [\n                r'\\d{2}/\\d{2}/\\d{2}',  # DD/MM/YY\n                r'\\d{1,2}/\\d{1,2}/\\d{2,4}',  # D/M/YY or DD/MM/YYYY\n                r'\\d{1,2}-\\d{1,2}-\\d{2,4}',  # D-M-YY\n            ]\n            return any(re.search(pattern, text) for pattern in date_patterns)\n        \n        def _is_distance(self, text: str) -> bool:\n            \"\"\"Check if text looks like a race distance.\"\"\"\n            return bool(re.search(r'\\d{3,4}[mM]', text))\n        \n        def _is_race_time(self, text: str) -> bool:\n            \"\"\"Check if text looks like a race time.\"\"\"\n            return bool(re.search(r'^\\d{2}\\.\\d{2}$', text))\n        \n        def _is_box_number(self, text: str) -> bool:\n            \"\"\"Check if text is a valid box number.\"\"\"\n            return text.isdigit() and 1 <= int(text) <= 8\n        \n        def _is_finish_position(self, text: str) -> bool:\n            \"\"\"Check if text is a finishing position.\"\"\"\n            # Plain numbers (1-8) or ordinals (1st, 2nd, etc.)\n            if text.isdigit() and 1 <= int(text) <= 8:\n                return True\n            return bool(re.search(r'\\d{1}(?:st|nd|rd|th)', text))\n        \n        def _is_grade(self, text: str) -> bool:\n            \"\"\"Check if text is a race grade.\"\"\"\n            return bool(re.search(r'^[0-9][A-Z]?$', text)) or 'grade' in text.lower()\n        \n        def _contains_racing_indicators(self, text: str) -> bool:\n            \"\"\"Check if text contains racing data indicators.\"\"\"\n            indicators = ['ballarat', 'bendigo', 'cannington', 'mandurah', '1st', '2nd', '3rd', 'box', 'time']\n            return any(indicator in text.lower() for indicator in indicators)\n        \n        def _parse_racing_text(self, text: str, dog_name: str) -> Optional[Dict[str, Any]]:\n            \"\"\"Parse racing data from free text.\"\"\"\n            \n            race_entry = {\n                'dog_name': dog_name,\n                'race_date': None,\n                'venue': None,\n                'distance': None,\n                'finish_position': None,\n                'actual_time': None,\n                'comments': text\n            }\n            \n            # Extract date\n            date_match = re.search(r'(\\d{2}/\\d{2}/\\d{2})', text)\n            if date_match:\n                race_entry['race_date'] = date_match.group(1)\n            \n            # Extract venue\n            for abbrev in ['CAN', 'MAN', 'BAL', 'BEN', 'SAN', 'MEL']:\n                if abbrev in text:\n                    race_entry['venue'] = self._expand_venue_abbreviation(abbrev)\n                    break\n            \n            # Extract distance\n            distance_match = re.search(r'(\\d{3,4}[mM])', text)\n            if distance_match:\n                race_entry['distance'] = distance_match.group(1)\n            \n            # Extract position\n            position_match = re.search(r'(\\d+)(?:st|nd|rd|th)', text)\n            if position_match:\n                race_entry['finish_position'] = int(position_match.group(1))\n            \n            # Extract time\n            time_match = re.search(r'(\\d{2}\\.\\d{2})', text)\n            if time_match:\n                race_entry['actual_time'] = float(time_match.group(1))\n            \n            return race_entry if (race_entry['race_date'] or race_entry['venue'] or race_entry['finish_position']) else None\n        \n        def _calculate_performance_metrics(self, form_entries: List[Dict[str, Any]]) -> Dict[str, Any]:\n            \"\"\"Calculate performance metrics using correct TGR data interpretation.\"\"\"\n            \n            if not form_entries:\n                return {}\n            \n            metrics = {\n                'total_starts': len(form_entries),\n                'wins': 0,\n                'seconds': 0,\n                'thirds': 0,\n                'win_percentage': 0.0,\n                'place_percentage': 0.0,\n                'average_time': 0.0,\n                'best_time': None,\n                'average_position': 0.0,\n                'positions': []\n            }\n            \n            times = []\n            positions = []\n            \n            for entry in form_entries:\n                # Count wins, seconds, thirds based on finish_position\n                position = entry.get('finish_position')\n                if position:\n                    positions.append(position)\n                    if position == 1:\n                        metrics['wins'] += 1\n                    elif position == 2:\n                        metrics['seconds'] += 1\n                    elif position == 3:\n                        metrics['thirds'] += 1\n                \n                # Collect actual times (individual dog's time, not winning time)\n                actual_time = entry.get('actual_time')\n                if actual_time:\n                    times.append(actual_time)\n            \n            if metrics['total_starts'] > 0:\n                metrics['win_percentage'] = (metrics['wins'] / metrics['total_starts']) * 100\n                place_count = metrics['wins'] + metrics['seconds'] + metrics['thirds']\n                metrics['place_percentage'] = (place_count / metrics['total_starts']) * 100\n                \n                if positions:\n                    metrics['average_position'] = sum(positions) / len(positions)\n                    metrics['positions'] = positions\n            \n            if times:\n                metrics['average_time'] = sum(times) / len(times)\n                metrics['best_time'] = min(times)\n            \n            return metrics\n        \n        def _analyze_venue_performance(self, form_entries: List[Dict[str, Any]]) -> Dict[str, Any]:\n            \"\"\"Analyze performance by venue using correct data.\"\"\"\n            \n            venue_stats = {}\n            \n            for entry in form_entries:\n                venue = entry.get('venue', 'Unknown')\n                if venue not in venue_stats:\n                    venue_stats[venue] = {\n                        'starts': 0,\n                        'wins': 0,\n                        'places': 0,\n                        'times': [],\n                        'positions': []\n                    }\n                \n                venue_stats[venue]['starts'] += 1\n                \n                position = entry.get('finish_position')\n                if position:\n                    venue_stats[venue]['positions'].append(position)\n                    if position == 1:\n                        venue_stats[venue]['wins'] += 1\n                    elif position in [2, 3]:\n                        venue_stats[venue]['places'] += 1\n                \n                actual_time = entry.get('actual_time')\n                if actual_time:\n                    venue_stats[venue]['times'].append(actual_time)\n            \n            # Calculate percentages and averages\n            for venue, stats in venue_stats.items():\n                if stats['starts'] > 0:\n                    stats['win_percentage'] = (stats['wins'] / stats['starts']) * 100\n                    stats['place_percentage'] = ((stats['wins'] + stats['places']) / stats['starts']) * 100\n                    \n                    if stats['positions']:\n                        stats['average_position'] = sum(stats['positions']) / len(stats['positions'])\n                \n                if stats['times']:\n                    stats['average_time'] = sum(stats['times']) / len(stats['times'])\n                    stats['best_time'] = min(stats['times'])\n            \n            return venue_stats\n        \n        def _analyze_distance_performance(self, form_entries: List[Dict[str, Any]]) -> Dict[str, Any]:\n            \"\"\"Analyze performance by distance using correct data.\"\"\"\n            \n            distance_stats = {}\n            \n            for entry in form_entries:\n                distance = entry.get('distance', 'Unknown')\n                if distance not in distance_stats:\n                    distance_stats[distance] = {\n                        'starts': 0,\n                        'wins': 0,\n                        'places': 0,\n                        'times': [],\n                        'positions': []\n                    }\n                \n                distance_stats[distance]['starts'] += 1\n                \n                position = entry.get('finish_position')\n                if position:\n                    distance_stats[distance]['positions'].append(position)\n                    if position == 1:\n                        distance_stats[distance]['wins'] += 1\n                    elif position in [2, 3]:\n                        distance_stats[distance]['places'] += 1\n                \n                actual_time = entry.get('actual_time')\n                if actual_time:\n                    distance_stats[distance]['times'].append(actual_time)\n            \n            # Calculate percentages and averages\n            for distance, stats in distance_stats.items():\n                if stats['starts'] > 0:\n                    stats['win_percentage'] = (stats['wins'] / stats['starts']) * 100\n                    stats['place_percentage'] = ((stats['wins'] + stats['places']) / stats['starts']) * 100\n                    \n                    if stats['positions']:\n                        stats['average_position'] = sum(stats['positions']) / len(stats['positions'])\n                \n                if stats['times']:\n                    stats['average_time'] = sum(stats['times']) / len(stats['times'])\n                    stats['best_time'] = min(stats['times'])\n            \n            return distance_stats\n        \n        def _extract_recent_comments(self, form_entries: List[Dict[str, Any]]) -> List[str]:\n            \"\"\"Extract recent comments from form entries.\"\"\"\n            \n            comments = []\n            \n            for entry in form_entries:\n                if entry.get('comments'):\n                    comments.append(entry['comments'])\n            \n            # Remove duplicates and filter short comments\n            unique_comments = list(set(comment for comment in comments if len(comment) > 10))\n            \n            return unique_comments[:20]  # Limit to 20 most recent\n    \n    return CorrectedTGRScraper\n\ndef test_corrected_scraper():\n    \"\"\"Test the corrected TGR scraper.\"\"\"\n    \n    logger.info(\"üß™ Testing Corrected TGR Scraper (Official Documentation Based)...\")\n    \n    CorrectedTGRScraper = create_corrected_tgr_scraper()\n    scraper = CorrectedTGRScraper(rate_limit=2.0, use_cache=True)\n    \n    # Test with known dogs\n    test_dogs = [\"Mayfield Star\", \"Salted Caramel\"]\n    \n    for dog_name in test_dogs:\n        logger.info(f\"\\nüêï Testing corrected data collection for: {dog_name}\")\n        enhanced_data = scraper.fetch_enhanced_dog_data(dog_name)\n        \n        logger.info(f\"Results for {dog_name}:\")\n        logger.info(f\"  Total race entries found: {len(enhanced_data.get('form_entries', []))}\")\n        \n        if enhanced_data.get('form_entries'):\n            sample_entry = enhanced_data['form_entries'][0]\n            logger.info(f\"  Sample race entry: {sample_entry}\")\n            \n            # Show corrected performance summary\n            performance = enhanced_data.get('performance_summary', {})\n            logger.info(f\"  Corrected Performance Summary:\")\n            logger.info(f\"    Total starts: {performance.get('total_starts', 0)}\")\n            logger.info(f\"    Wins: {performance.get('wins', 0)}\")\n            logger.info(f\"    Seconds: {performance.get('seconds', 0)}\")\n            logger.info(f\"    Thirds: {performance.get('thirds', 0)}\")\n            logger.info(f\"    Win %: {performance.get('win_percentage', 0):.1f}%\")\n            logger.info(f\"    Place %: {performance.get('place_percentage', 0):.1f}%\")\n            logger.info(f\"    Average position: {performance.get('average_position', 0):.1f}\")\n            logger.info(f\"    Best time: {performance.get('best_time', 'N/A')}\")\n            logger.info(f\"    Average time: {performance.get('average_time', 0):.2f}\")\n            \n            # Show venue analysis\n            venue_analysis = enhanced_data.get('venue_analysis', {})\n            if venue_analysis:\n                logger.info(f\"  Venue Analysis:\")\n                for venue, stats in list(venue_analysis.items())[:3]:\n                    logger.info(f\"    {venue}: {stats.get('starts', 0)} starts, {stats.get('win_percentage', 0):.1f}% win, avg pos: {stats.get('average_position', 0):.1f}\")\n        \n        logger.info(f\"  Comments collected: {len(enhanced_data.get('recent_comments', []))}\")\n        \n        # Test with first dog and break to avoid rate limiting\n        if enhanced_data.get('form_entries'):\n            break\n\ndef main():\n    \"\"\"Main function to test the corrected TGR scraper.\"\"\"\n    \n    logger.info(\"üöÄ Creating Corrected TGR Scraper Based on Official Documentation...\")\n    \n    test_corrected_scraper()\n    \n    logger.info(\"\\n‚úÖ Corrected TGR scraper testing complete!\")\n    logger.info(\"üí° Key corrections made:\")\n    logger.info(\"  - F = Finishing Position (1, 2, 3, etc.)\")\n    logger.info(\"  - AT = Actual Time (individual dog's time)\")\n    logger.info(\"  - WT = Winning Time (winner's time for that race)\")\n    logger.info(\"  - Proper win/place/show counting\")\n    logger.info(\"  - Correct venue abbreviation expansion\")\n\nif __name__ == \"__main__\":\n    main()
