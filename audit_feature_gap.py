#!/usr/bin/env python3
"""
Feature Gap Analysis Script
============================

Compare the features expected by the V4 model with the features currently
being generated by the temporal feature builder and identify gaps.
"""

import json
import os
from pathlib import Path
import pandas as pd
import numpy as np

# Load the model contract
def load_model_contract():
    """Load the expected model features from the contract file."""
    contract_path = Path("docs/model_contracts/V4_ExtraTrees_20250819.json")
    
    if not contract_path.exists():
        print("âŒ Model contract file not found. Run inspect_model_features.py first.")
        return None
    
    with open(contract_path, 'r') as f:
        contract = json.load(f)
    
    return contract['features']

def analyze_current_features():
    """Analyze what features are currently being generated."""
    
    print("ğŸ” Analyzing current feature generation...")
    
    # Look at temporal feature builder default features
    temporal_defaults = {
        'historical_avg_position': 4.5,
        'historical_best_position': 4.0,
        'historical_win_rate': 0.125,
        'historical_place_rate': 0.375,
        'historical_form_trend': 0.0,
        'historical_avg_time': 30.0,
        'historical_best_time': 29.0,
        'historical_time_consistency': 2.0,
        'venue_specific_avg_position': 4.5,
        'venue_specific_win_rate': 0.125,
        'venue_experience': 0,
        'venue_best_position': 4.0,
        'grade_specific_avg_position': 4.5,
        'grade_specific_win_rate': 0.125,
        'grade_experience': 0,
        'days_since_last_race': 30.0,
        'race_frequency': 2.0,
        'best_distance_avg_position': 4.5,
        'best_distance_win_rate': 0.125,
        'distance_adjusted_time': False,  # boolean flag
        'target_distance': 0.0
    }
    
    # Pre-race features from temporal builder
    pre_race_features = {
        'box_number', 'weight', 'trainer_name', 'dog_clean_name', 'venue', 'grade', 'distance',
        'track_condition', 'weather', 'temperature', 'humidity', 'wind_speed',
        'field_size', 'race_date', 'race_time'
    }
    
    current_features = set(temporal_defaults.keys()) | pre_race_features
    
    print(f"ğŸ“Š Current feature builder generates {len(current_features)} features:")
    for feature in sorted(current_features):
        print(f"  âœ“ {feature}")
    
    return current_features

def compare_features(expected_features, current_features):
    """Compare expected vs current features and identify gaps."""
    
    expected_set = set(expected_features)
    current_set = set(current_features)
    
    missing_features = expected_set - current_set
    extra_features = current_set - expected_set
    common_features = expected_set & current_set
    
    print("\n" + "="*60)
    print("FEATURE GAP ANALYSIS")
    print("="*60)
    
    print(f"âœ… Features correctly implemented: {len(common_features)}")
    for feature in sorted(common_features):
        print(f"   âœ“ {feature}")
    
    print(f"\nâŒ Missing features (model expects but not generated): {len(missing_features)}")
    for feature in sorted(missing_features):
        print(f"   âŒ {feature}")
    
    print(f"\nâš ï¸ Extra features (generated but model doesn't use): {len(extra_features)}")
    for feature in sorted(extra_features):
        print(f"   âš ï¸ {feature}")
    
    return {
        'missing': missing_features,
        'extra': extra_features,
        'common': common_features
    }

def suggest_fixes(missing_features):
    """Suggest how to implement missing features."""
    
    print("\n" + "="*60)
    print("IMPLEMENTATION SUGGESTIONS")
    print("="*60)
    
    # Group features by likely implementation approach
    direct_mapping = {
        'race_date': 'Already available in race data, may need formatting',
        'weather': 'Already available in race data',
        'venue': 'Already available in race data', 
        'humidity': 'Already available in race data',
        'trainer_name': 'Already available in race data',
        'weight': 'Already available in race data',
        'box_number': 'Already available in race data',
        'wind_speed': 'Already available in race data',
        'temperature': 'Already available in race data',
        'grade': 'Already available in race data',
        'field_size': 'Already available in race data',
        'distance': 'Map from target_distance or race distance',
        'track_condition': 'Already available in race data'
    }
    
    already_implemented = {
        'historical_avg_position': 'Already implemented in temporal builder',
        'historical_best_position': 'Already implemented in temporal builder', 
        'historical_win_rate': 'Already implemented in temporal builder',
        'historical_place_rate': 'Already implemented in temporal builder',
        'historical_form_trend': 'Already implemented in temporal builder',
        'historical_avg_time': 'Already implemented in temporal builder',
        'historical_best_time': 'Already implemented in temporal builder',
        'historical_time_consistency': 'Already implemented in temporal builder',
        'distance_adjusted_time': 'Already implemented in temporal builder',
        'target_distance': 'Already implemented in temporal builder',
        'venue_specific_avg_position': 'Already implemented in temporal builder',
        'venue_specific_win_rate': 'Already implemented in temporal builder', 
        'venue_experience': 'Already implemented in temporal builder',
        'venue_best_position': 'Already implemented in temporal builder',
        'grade_specific_avg_position': 'Already implemented in temporal builder',
        'grade_specific_win_rate': 'Already implemented in temporal builder',
        'grade_experience': 'Already implemented in temporal builder',
        'days_since_last_race': 'Already implemented in temporal builder',
        'race_frequency': 'Already implemented in temporal builder',
        'best_distance_avg_position': 'Already implemented in temporal builder',
        'best_distance_win_rate': 'Already implemented in temporal builder'
    }
    
    for feature in sorted(missing_features):
        if feature in direct_mapping:
            print(f"âœ… {feature}: {direct_mapping[feature]}")
        elif feature in already_implemented:
            print(f"ğŸ”„ {feature}: {already_implemented[feature]} - Check naming/mapping")
        else:
            print(f"ğŸš¨ {feature}: NEW IMPLEMENTATION REQUIRED")
    
    print("\nğŸ“ Key Actions Needed:")
    print("1. Update feature_store.py to load the model contract and enforce column alignment")
    print("2. Fix naming mismatches between temporal builder and model expectations")
    print("3. Ensure pre-race features are properly extracted from race data")
    print("4. Add missing features (if any require new logic)")

def generate_feature_mapping():
    """Generate a mapping from current features to expected features."""
    
    mapping = {
        # Direct mappings that should work
        'distance': 'target_distance',  # May need to use race distance
        'box_number': 'box_number',
        'weight': 'weight', 
        'trainer_name': 'trainer_name',
        'venue': 'venue',
        'grade': 'grade',
        'track_condition': 'track_condition',
        'weather': 'weather',
        'temperature': 'temperature',
        'humidity': 'humidity',
        'wind_speed': 'wind_speed',
        'field_size': 'field_size',
        'race_date': 'race_date',
        
        # Historical features (should be generated by temporal builder)
        'historical_avg_position': 'historical_avg_position',
        'historical_best_position': 'historical_best_position', 
        'historical_win_rate': 'historical_win_rate',
        'historical_place_rate': 'historical_place_rate',
        'historical_form_trend': 'historical_form_trend',
        'historical_avg_time': 'historical_avg_time',
        'historical_best_time': 'historical_best_time',
        'historical_time_consistency': 'historical_time_consistency',
        'distance_adjusted_time': 'distance_adjusted_time',
        'target_distance': 'target_distance',
        'venue_specific_avg_position': 'venue_specific_avg_position',
        'venue_specific_win_rate': 'venue_specific_win_rate',
        'venue_experience': 'venue_experience', 
        'venue_best_position': 'venue_best_position',
        'grade_specific_avg_position': 'grade_specific_avg_position',
        'grade_specific_win_rate': 'grade_specific_win_rate',
        'grade_experience': 'grade_experience',
        'days_since_last_race': 'days_since_last_race',
        'race_frequency': 'race_frequency',
        'best_distance_avg_position': 'best_distance_avg_position',
        'best_distance_win_rate': 'best_distance_win_rate'
    }
    
    # Save mapping to file
    mapping_path = Path("docs/model_contracts/feature_mapping.json")
    mapping_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(mapping_path, 'w') as f:
        json.dump(mapping, f, indent=2)
    
    print(f"\nğŸ’¾ Feature mapping saved to: {mapping_path}")
    return mapping

def main():
    print("ğŸ” Starting comprehensive feature gap analysis...")
    
    # Load expected features from model contract  
    expected_features = load_model_contract()
    if expected_features is None:
        return
    
    print(f"ğŸ“‹ Model expects {len(expected_features)} features:")
    for i, feature in enumerate(expected_features, 1):
        print(f"  {i:2d}. {feature}")
    
    # Analyze current feature generation
    current_features = analyze_current_features()
    
    # Compare and identify gaps
    comparison = compare_features(expected_features, current_features)
    
    # Generate suggestions
    suggest_fixes(comparison['missing'])
    
    # Generate feature mapping
    mapping = generate_feature_mapping()
    
    print("\n" + "="*60)
    print("SUMMARY")
    print("="*60)
    print(f"Model expects: {len(expected_features)} features")
    print(f"Currently generating: {len(current_features)} features")
    print(f"âœ… Correctly implemented: {len(comparison['common'])}")
    print(f"âŒ Missing: {len(comparison['missing'])}")
    print(f"âš ï¸ Extra: {len(comparison['extra'])}")
    
    if comparison['missing']:
        print(f"\nğŸ¯ Priority: Fix {len(comparison['missing'])} missing features to resolve model prediction failures")
    else:
        print("\nğŸ‰ All expected features are being generated!")

if __name__ == "__main__":
    main()
