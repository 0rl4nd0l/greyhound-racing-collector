"""
SQLAlchemy models for the greyhound racing database.
This file defines the database schema for Alembic migrations and consistency tests.
"""

from sqlalchemy import (Column, Integer, String, Float, Date, Text, Boolean, 
                       DateTime, ForeignKey, Index, UniqueConstraint, Numeric, Enum)
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql import func
from datetime import datetime
from typing import List, Optional, Dict, Any
from dataclasses import dataclass
from enum import Enum as PyEnum
import json

Base = declarative_base()


# =============================================================================
# GPTAssistant Data Models and Enums
# =============================================================================

class Severity(PyEnum):
    """Issue severity levels for GPTAssistant system."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class IssueType(PyEnum):
    """Types of issues that can be detected."""
    DATA_COMPLETENESS = "data_completeness"
    DATA_CONSISTENCY = "data_consistency"
    PREDICTION_ACCURACY = "prediction_accuracy"
    MODEL_PERFORMANCE = "model_performance"
    FORM_VALIDATION = "form_validation"
    ANOMALY_DETECTION = "anomaly_detection"
    SYSTEM_ERROR = "system_error"


@dataclass
class PredictionRecord:
    """Data model for prediction records parsed from logs."""
    race_id: str
    dog_name: str
    prediction_value: float
    confidence: float
    timestamp: datetime
    model_version: str
    form_data: Dict[str, Any]
    validation_errors: List[str]
    
    def __post_init__(self):
        """Validate the prediction record after initialization."""
        if not self.race_id:
            raise ValueError("race_id cannot be empty")
        if not self.dog_name:
            raise ValueError("dog_name cannot be empty")
        if not 0 <= self.prediction_value <= 1:
            raise ValueError("prediction_value must be between 0 and 1")
        if not 0 <= self.confidence <= 1:
            raise ValueError("confidence must be between 0 and 1")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'race_id': self.race_id,
            'dog_name': self.dog_name,
            'prediction_value': self.prediction_value,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
            'model_version': self.model_version,
            'form_data': self.form_data,
            'validation_errors': self.validation_errors
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PredictionRecord':
        """Create from dictionary."""
        return cls(
            race_id=data['race_id'],
            dog_name=data['dog_name'],
            prediction_value=data['prediction_value'],
            confidence=data['confidence'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            model_version=data['model_version'],
            form_data=data['form_data'],
            validation_errors=data['validation_errors']
        )


@dataclass
class GuideIssue:
    """Data model for issues identified during analysis."""
    issue_id: str
    issue_type: IssueType
    severity: Severity
    description: str
    affected_records: List[str]
    recommendation: str
    metadata: Dict[str, Any]
    
    def __post_init__(self):
        """Validate the guide issue after initialization."""
        if not self.issue_id:
            raise ValueError("issue_id cannot be empty")
        if not self.description:
            raise ValueError("description cannot be empty")
        if not self.recommendation:
            raise ValueError("recommendation cannot be empty")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'issue_id': self.issue_id,
            'issue_type': self.issue_type.value,
            'severity': self.severity.value,
            'description': self.description,
            'affected_records': self.affected_records,
            'recommendation': self.recommendation,
            'metadata': self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GuideIssue':
        """Create from dictionary."""
        return cls(
            issue_id=data['issue_id'],
            issue_type=IssueType(data['issue_type']),
            severity=Severity(data['severity']),
            description=data['description'],
            affected_records=data['affected_records'],
            recommendation=data['recommendation'],
            metadata=data['metadata']
        )


@dataclass
class AdvisoryMessage:
    """Data model for advisory messages generated by the system."""
    advisory_id: str
    title: str
    summary: str
    details: str
    severity: Severity
    action_items: List[str]
    created_at: datetime
    expires_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Validate the advisory message after initialization."""
        if not self.advisory_id:
            raise ValueError("advisory_id cannot be empty")
        if not self.title:
            raise ValueError("title cannot be empty")
        if not self.summary:
            raise ValueError("summary cannot be empty")
        if not self.action_items:
            raise ValueError("action_items cannot be empty")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'advisory_id': self.advisory_id,
            'title': self.title,
            'summary': self.summary,
            'details': self.details,
            'severity': self.severity.value,
            'action_items': self.action_items,
            'created_at': self.created_at.isoformat(),
            'expires_at': self.expires_at.isoformat() if self.expires_at else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AdvisoryMessage':
        """Create from dictionary."""
        return cls(
            advisory_id=data['advisory_id'],
            title=data['title'],
            summary=data['summary'],
            details=data['details'],
            severity=Severity(data['severity']),
            action_items=data['action_items'],
            created_at=datetime.fromisoformat(data['created_at']),
            expires_at=datetime.fromisoformat(data['expires_at']) if data['expires_at'] else None
        )


class RaceMetadata(Base):
    __tablename__ = 'race_metadata'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    race_id = Column(String, unique=True)
    venue = Column(String)
    race_number = Column(Integer)
    race_date = Column(Date)
    race_name = Column(String)
    grade = Column(String)
    distance = Column(String)
    track_condition = Column(String)
    weather = Column(String)
    temperature = Column(Float)
    humidity = Column(Float)
    wind_speed = Column(Float)
    wind_direction = Column(String)
    track_record = Column(String)
    prize_money_total = Column(Float)
    prize_money_breakdown = Column(String)
    race_time = Column(String)
    field_size = Column(Integer)
    url = Column(String)
    extraction_timestamp = Column(DateTime)
    data_source = Column(String)
    winner_name = Column(String)
    winner_odds = Column(Float)
    winner_margin = Column(Float)
    race_status = Column(String)
    data_quality_note = Column(String)
    actual_field_size = Column(Integer)
    scratched_count = Column(Integer)
    scratch_rate = Column(Float)
    box_analysis = Column(String)
    weather_condition = Column(String)
    precipitation = Column(Float)
    pressure = Column(Float)
    visibility = Column(Float)
    weather_location = Column(String)
    weather_timestamp = Column(DateTime)
    weather_adjustment_factor = Column(Float)
    sportsbet_url = Column(String)
    venue_slug = Column(String)
    start_datetime = Column(DateTime)

    # Indexes for performance
    __table_args__ = (
        Index('idx_race_metadata_venue_date', 'venue', 'race_date'),
        Index('idx_race_metadata_race_id', 'race_id'),
        UniqueConstraint('race_id', name='uq_race_metadata_race_id'),
    )


class DogRaceData(Base):
    __tablename__ = 'dog_race_data'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    race_id = Column(String, ForeignKey('race_metadata.race_id', ondelete='CASCADE'))
    dog_name = Column(String)
    dog_clean_name = Column(String)
    dog_id = Column(Integer)
    box_number = Column(Integer)
    trainer_name = Column(String)
    trainer_id = Column(Integer)
    weight = Column(Float)
    running_style = Column(String)
    odds_decimal = Column(Float)
    odds_fractional = Column(String)
    starting_price = Column(Float)
    individual_time = Column(String)
    sectional_1st = Column(String)
    sectional_2nd = Column(String)
    sectional_3rd = Column(String)
    margin = Column(String)
    beaten_margin = Column(Float)
    was_scratched = Column(Boolean)
    blackbook_link = Column(String)
    extraction_timestamp = Column(DateTime)
    data_source = Column(String)
    form_guide_json = Column(Text)
    historical_records = Column(Text)
    performance_rating = Column(Float)
    speed_rating = Column(Float)
    class_rating = Column(Float)
    recent_form = Column(String)
    win_probability = Column(Float)
    place_probability = Column(Float)
    scraped_trainer_name = Column(String)
    scraped_reaction_time = Column(String)
    scraped_nbtt = Column(String)
    scraped_race_classification = Column(String)
    scraped_raw_result = Column(String)
    scraped_finish_position = Column(String)
    best_time = Column(Float)
    data_quality_note = Column(String)
    finish_position = Column(Integer)
    odds = Column(String)
    trainer = Column(String)
    winning_time = Column(String)
    placing = Column(Integer)
    form = Column(String)

    # Indexes for performance and foreign key relationships
    __table_args__ = (
        Index('idx_dog_race_data_race_id', 'race_id'),
        Index('idx_dog_race_data_dog_name', 'dog_clean_name'),
        Index('idx_dog_race_data_finish_position', 'finish_position'),
        Index('idx_dog_name', 'dog_clean_name'),
        UniqueConstraint('race_id', 'dog_clean_name', 'box_number', 
                        name='idx_dog_race_unique'),
    )


class Dogs(Base):
    __tablename__ = 'dogs'
    
    dog_id = Column(Integer, primary_key=True, autoincrement=True)
    dog_name = Column(String, unique=True, nullable=False)
    total_races = Column(Integer, default=0)
    total_wins = Column(Integer, default=0)
    total_places = Column(Integer, default=0)
    best_time = Column(Float)
    average_position = Column(Float)
    last_race_date = Column(String)
    created_at = Column(DateTime, default=func.current_timestamp())
    weight = Column(Numeric(5, 2))
    age = Column(Integer)
    id = Column(Integer)
    color = Column(String)
    owner = Column(String)
    trainer = Column(String)
    sex = Column(String)

    # Indexes for performance
    __table_args__ = (
        Index('idx_dogs_clean_name', 'dog_name'),
        Index('idx_dogs_trainer', 'trainer'),
    )


# Additional tables for completeness (if they exist in your database)
class MLModelRegistry(Base):
    __tablename__ = 'ml_model_registry'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    model_name = Column(String, nullable=False)
    model_version = Column(String, nullable=False)
    model_type = Column(String)
    file_path = Column(String)
    metrics = Column(Text)
    parameters = Column(Text)
    training_data_hash = Column(String)
    is_active = Column(Boolean, default=False)
    created_at = Column(DateTime, default=func.current_timestamp())
    updated_at = Column(DateTime, default=func.current_timestamp(), onupdate=func.current_timestamp())

    __table_args__ = (
        UniqueConstraint('model_name', 'model_version', name='uq_model_registry_name_version'),
    )


class PredictionHistory(Base):
    __tablename__ = 'prediction_history'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    race_id = Column(String, ForeignKey('race_metadata.race_id'))
    model_name = Column(String)
    model_version = Column(String)
    prediction_data = Column(Text)
    confidence_score = Column(Float)
    actual_results = Column(Text)
    accuracy_score = Column(Float)
    created_at = Column(DateTime, default=func.current_timestamp())
    updated_at = Column(DateTime, default=func.current_timestamp(), onupdate=func.current_timestamp())

    __table_args__ = (
        Index('idx_prediction_history_race_id', 'race_id'),
        Index('idx_prediction_history_model', 'model_name', 'model_version'),
    )


class ProcessedRaceFiles(Base):
    __tablename__ = 'processed_race_files'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    file_hash = Column(String(64), unique=True, nullable=False)  # SHA-256 hash
    race_date = Column(Date, nullable=False)
    venue = Column(String, nullable=False)
    race_no = Column(Integer, nullable=False)
    file_path = Column(String, nullable=False)
    file_size = Column(Integer)
    processed_at = Column(DateTime, default=func.current_timestamp())
    status = Column(String, default='processed')  # processed, failed, skipped
    error_message = Column(Text)
    
    # Indexes for performance
    __table_args__ = (
        Index('idx_processed_files_hash', 'file_hash'),
        Index('idx_processed_files_race_key', 'race_date', 'venue', 'race_no'),
        Index('idx_processed_files_processed_at', 'processed_at'),
        UniqueConstraint('file_hash', name='uq_processed_files_hash'),
    )


class DatabaseMeta(Base):
    __tablename__ = 'db_meta'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    meta_key = Column(String(255), unique=True, nullable=False)
    meta_value = Column(String(500))
    last_updated = Column(DateTime, default=func.current_timestamp(), onupdate=func.current_timestamp())
    
    # Indexes for performance
    __table_args__ = (
        Index('idx_db_meta_key', 'meta_key'),
        UniqueConstraint('meta_key', name='uq_db_meta_key'),
    )
